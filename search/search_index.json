{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Penne is the first client library to implement the NOODLES messaging protocol in Python. NOODLES allows multiple client applications to interact collaboratively with data in real-time. The client uses a websocket connection to send CBOR  encoded messages, and all components in the scene graph can be subclassed and customized to fit an application's  needs.</p>   video  Penne used as the foundation for Orzo's 3d visualizations"},{"location":"#why-use-penne","title":"Why use Penne?","text":"<p>Penne is a great choice for anyone who wants to use the NOODLES protocol while working in Python. With a client application to display methods and data, users will be able to interact with data from any server that implements the NOODLES protocol. Penne offers a simple interface for handling messages and customizing components in a scene. If you are looking to use NOODLES with a different language, there is currently support for C++, Rust,  Julia, and Javascript here, and if you are looking to build a server in  Python, check out Rigatoni.</p>"},{"location":"#how-does-the-client-work","title":"How does the client work?","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Delegate\n    participant Client\n    participant Server\n    User-&gt;&gt;Delegate: Create Custom Delegates\n    User-&gt;&gt;Client: Starts Server with Custom Delegates\n    Client-&gt;&gt;Server: Sends Intro Message\n    Server-&gt;&gt;Client: Updates the Client with Current State\n    loop until end of session\n        User-&gt;&gt;Delegate: Invoke Injected or Custom Method on Delegate or...\n        User-&gt;&gt;Client: Invoke Method on Client Directly\n        Client-&gt;&gt;Server: Request to Invoke Method\n        Server-&gt;&gt;Client: Responds to Update State\n        Client-&gt;&gt;Delegate: Invokes Signals, Creates, Updates, and Deletes Delegates\n        Client-&gt;&gt;User: Show Current State\n    end</code></pre> <p>When a message is received from the server, the client passes the CBOR encoded message to a handler function which uses the message's ID to process it accordingly. Based on this ID, the message can be classified as either a create, delete,  update, reply, or invoke message. Upon receiving a create message, the handler creates a new delegate for that object which is then stored in the client's state. Delete and update messages manipulate delegates in the client's state as expected.  Reply messages indicate whether a method was invoked on the server successfully, and then a callback function can be  executed if applicable. Lastly, invoke messages represent signals from the server which are being called on a delegate.  The handler sends this signal to the target delegate so it can call a corresponding function. </p> <p>To send a message, the user calls a method on a delegate or the document more broadly. Delegates may have injected  methods from the server, and the client can send a message invoking the method. For example, the server can define a method like insert_row() on a table delegate. The client can then call this method on the delegate, and the server will get a message requesting to invoke the method. The server will then respond by updating the state, invoking signals,  and sending a reply message to the client. If the server is unable to invoke the method, it will send a reply message that contains an exception.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install the library <pre><code>pip install penne\n</code></pre></li> <li>Create a client using  <pre><code>from penne import Client\n\nwith Client(address, delegate_hash) as client:\n    # do stuff\n</code></pre></li> <li>(Optional) use delegate hash to map custom delegates</li> <li>This is the recommended way to create a client as it will automatically close the connection when the client goes out of scope</li> <li>It also manages an 'is_active' flag to signify whether the connection is open and the client is still running</li> <li>This can be used to poll for callbacks</li> <li>However, you can also instantiate the client and manage the communication thread manually <pre><code>client = Client(address, delegate_hash)\nclient.thread.start()  # Starts websocket connection in new thread\nclient.connection_established.wait() \n# do stuff\nclient.shutdown()  # Close websocket connection\nclient.thread.join()\n</code></pre></li> <li>Explore and manipulate data on the server using client or delegate methods</li> <li>call <code>show_methods()</code> on the client to see a list of available methods with documentation</li> <li>call <code>show_methods()</code> on a delegate to see a list of available methods for that instance</li> </ol>"},{"location":"basic_usage/","title":"Basic usage","text":"<ol> <li>Define delegates</li> <li>Start up the client</li> </ol>"},{"location":"basic_usage/#working-with-delegates","title":"Working with delegates","text":"<p>What are delegates? </p> <p>NOODLES messages deal with many objects ranging from tables and plots to lights and materials. To help with  using these objects, each type has its own delegate class. Each object in a scene corresponds with an instance of a delegate which is stored in the client's state. Delegates provide methods specific to each type of object. These objects can contain  injected methods and signals from the server. All delegates come with methods <code>on_new()</code>, <code>on_update()</code>, and <code>on_remove()</code> which are called automatically when the server sends a message to create, update, or delete an object.</p> <p>How can I customize delegates?</p> <p>To work with your own delegates, simply create a class that inherits from the base delegate. Then, pass a dictionary as an argument to the server that maps the delegate's type to the new class. In <code>tests/clients.py</code> there is a more involved example that extends the table delegate. In that example, the delegate class  inherits from <code>Table</code> and uses pandas and matplotlib to add plotting functionality. Below is an even more basic example that prints a message whenever a new method is created.</p> <p>Note</p> <p>In this library, delegates are Pydantic models. This means that they come with some built in functionality, and it might be helpful to read the Pydantic docs to learn more about how to use them.</p> <pre><code>from penne import Method, Client\n\n\nclass CustomMethod(Method):\n\n  def on_new(self, message: dict):\n    print(f\"New method named {self.name} was created\")\n\n\nwith Client(\"ws://localhost:50000\", {Method: CustomMethod}) as client:\n  # do stuff\n</code></pre> <p>How do you call methods on a delegate?</p> <p>Once instantiated, delegates are injected with methods designated by the server. These methods can be called by using public methods on the delegate that essentially wrap the injected ones. Once the method is invoked, the server will  respond with a signal that updates the client. Each signal is linked to a method in the delegate which keeps the state of  the client up to date. To customize the client's behavior, these methods can be overwritten in a custom delegate. Each  public method also accepts a callback function to be executed once a response is received from the server.  This way, method calls can be chained together and run in sequence. A common example is the <code>Table</code> delegate. The server by default will define methods to insert, remove, and update rows in the table. The client can request to call these  injected methods, and then the server will send a signal back to the client to update the table if the call was  successful. An example is provided in <code>tests/plottyn_integration.py</code>.</p>"},{"location":"basic_usage/#tables","title":"Tables","text":"<p>The table delegate comes with several built in methods covering basic table manipulation. The delegate includes... <pre><code>subscribe(on_done=None)\nrequest_insert(row_list: list=None, on_done=None)\nrequest_remove(keys: list, on_done=None)\nrequest_update(keys: List[int], rows: List[List[int]], on_done=None)\nrequest_clear(on_done=None)\nrequest_update_selection(name: str, keys: list, on_done=None)\n</code></pre></p> <p>When using these methods, the user has the option of including a callback function (on_done) that will execute once complete. Once invoked, signals from the server will update the table in the delegate. For the table thereare several signals that can be overwritten in a custom delegate. While you can inherit and customize them for your specif implementation of the table, they should not be called directly by users. They will be called when indicated by a message from the server.  These include... <pre><code>_on_table_init(init_info: dict, on_done=None)\n_reset_table(init_info: dict)\n_remove_rows(keys: list[int])\n_update_rows(keys: list[int], rows: list[list])\n_update_selection(selection: dict)\n</code></pre></p>"},{"location":"basic_usage/#starting-up-the-client","title":"Starting up the client","text":"<p>The easiest way to create a client instance is to use the context manager. This will automatically start the websocket connection and communication thread while closing it when the client goes out of scope. To add custom delegates, simply use the optional parameter <code>delegate_hash</code> to map the delegate type to a custom class. The context manager also manages an 'is_active' flag to signify whether the connection is open and the client is still running. This can be used to poll for callbacks. The client also has a couple of other optional parameters. Users can specify a method to  be called as soon as the client is connected with <code>on_connected</code>. The client validates incoming messages and coerces them into the correct type. By default, this will log an error to indicate that the server is not conforming to the protocol exactly. To change these warnings into hard exceptions, set <code>strict</code> to <code>True</code>. Lastly, putting a file path for the json parameter will cause the client to write all incoming messages to that file. This can be useful for debugging or logging purposes. <pre><code>from penne import Client\n\nwith Client(address, delegate_hash) as client:\n    # do stuff\n</code></pre></p> <p>However, you can also instantiate the client and manage the communication thread manually. This may be useful if you want to run the client from the REPL. <pre><code>client = Client(address, delegate_hash)\nclient.thread.start()  # Starts websocket connection in new thread\nclient.connection_established.wait()  # Usually isn't a problem when using the REPL\n# do stuff\nclient.shutdown()  # Close websocket connection and join the thread\n</code></pre></p>"},{"location":"contributing/","title":"Contributing","text":"<p>Any help with the project would be super appreciated. Here are some steps to get started.</p> <ol> <li>Clone the repo</li> <li>Install the dependencies    <pre><code>pip install -r requirements.txt\npip install -r tests/requirements.txt\n</code></pre></li> <li>Switch to the <code>develop</code> branch or create a new one</li> <li>Make your changes</li> <li>To update the documentation, simply edit the docstrings for each method.</li> <li>Run the tests<ul> <li>These flags will help show which lines are missing test coverage    <pre><code> pytest --cov penne --cov-report term-missing\n</code></pre></li> </ul> </li> <li>Submit a pull request<ul> <li>There are github actions set up to run the tests and build the docs for each pull request.</li> </ul> </li> </ol>"},{"location":"install/","title":"Install","text":"<p>Installation is as simple as:</p> <pre><code>pip install penne\n</code></pre> <p>Penne has a few dependencies:</p> <ul> <li><code>websockets</code>: Websocket connections in Python.</li> <li><code>cbor2</code>: Concise Binary Object Representation for messages.</li> <li><code>pydantic</code>: Data validation and coercion for parsing messages.</li> <li><code>pydantic-extra-types</code>: Easy to use color format</li> </ul> <p>If you've got Python 3.9+ and <code>pip</code> installed, you're good to go.</p> <p>Note</p> <p>For stability, Penne's dependencies are pinned to specific versions. While these are up to date as of August 2023, you may want to update them to the latest versions. To do so, simply update the package yourself.</p>"},{"location":"noodles/","title":"What is NOODLES?","text":"<p>NOODLES is a messaging protocol for interactive visualizations. Client and server libraries can implement the protocol to allow for real-time collaboration across visually rich applications.</p> <p>As an intern with little experience in the field of data visualiation and computer graphics, I struggled at first to understand what exactly NOODLES is about and what it aims to accomplish. This document aims to help explain the project to newcomers with all that I have learned while working on Penne, Rigatoni, and Orzo.</p> <p>NOODLES is at its core is a messaging protocol. This is simply an agreement between client and server applications, so  they can communicate in a standardized way. The ultimate goal is to allow for real-time collaboration across different devices or client applications. For example, researchers could all be working on the same data set at the same time  while visualizing it from a web browser, a VR headset, or a command line interface. Researchers no longer would have to set up their data in a specific way to work with a particular visualization tool. Instead, they could use NOODLES to connect their data to any tool that implements the protocol. The NOODLES protocol would be the  bridge between these different tools and devices.</p> <p>While NOODLES specifically refers to the protocol that defines the types of messages that can be sent, this project includes client and server libraries that implement the protocol in a specific language. That way, users can use the  protocol in their language of choice. As of writing this, there is support for python, rust, c++, javascript, and julia.</p>"},{"location":"noodles/#breaking-down-a-noodles-session","title":"Breaking down a NOODLES session","text":"<p>A NOODLES session is composed of a server and one or more clients. A server hosts data and handles requests from clients to manipulate that data. Clients connect to the server with an introductory message and can request data from the server or send messages to the server to invoke methods that manipulate the data. The server then sends updates to all connected clients to keep them in sync.</p>"},{"location":"noodles/#objects-in-a-session","title":"Objects in a Session","text":"<p>If you look at the message specification, you'll notice that the messages follow a pattern. In general, most messages signal the creation, deletion, or modification of an object. These objects include lights, geometries, buffers, and more. These objects are all used to compose a scene that can be  rendered in 3d. Below is a diagram that shows the basic layout of the scene graph. For information on each type of  object, check out the latter half of this page.</p> <p></p>"},{"location":"noodles/#methods-and-signals","title":"Methods and Signals","text":"<p>The server defines methods that can be invoked by clients to manipulate the data. For the client this is like getting a menu at a restaurant. If the client invokes a method to say add a point to a data table, the server will process that  message then send a signal to all connected clients to let them know that the data has been updated. The server will also send a reply to let the client know whether the method invocation went through alright.</p>"},{"location":"noodles/#a-spheres-journey","title":"A sphere's journey","text":"<p>To get an idea of how all of these pieces come together to get something 3d to show up on a screen, I figured it would be helpful to walk through an example. Consider the humble sphere...</p> <p></p> <p>First a server application will define some methods that create the sphere, or maybe it will already be present in the server's starting state. This is a problem for the server application which would use the support of a server  library to make this happen. The client connects to the server's websocket address with an intro message, and the server sends back a series of messages to catch the client up to the server's current state. In this example, that would include an entity create message for the general entity that would hold the sphere. Entities are essentially containers that  house lights, geometry, and plots while storing important position information. There would also be a geometry creation message for the sphere geometry / mesh. There would also be buffer create messages for the binary data that makes up this geometry. The buffers could store positions, colors, normals, instances, and more essential information that allow the client to render the sphere. Buffer views let you know how to interpret this binary data. There could possibly be materials and textures messages that would allow the client to render the sphere with unique colors and texture. If there was a texture, you can think of it as a sort of wrapping paper that gets applied to the sphere. An image creation message would be sent to tell the client what this wrapping paper looks like,  and a sampler would let the client know how to apply the wrapping paper to the sphere.  With all of these pieces the client has everything it needs to render the sphere, and we have used most objects in the  scene graph diagram above.</p> <p>While this is pretty surface level, I hope it gives you a rough idea of how the pieces of the protocol fits together. If you want to learn more about how the client would use these pieces to render the sphere, check out Orzo's documentation.</p>"},{"location":"noodles/#more-info","title":"More Info","text":"<ul> <li>Full Message Specification</li> <li>More Client and Server Libraries</li> </ul>"},{"location":"api_reference/client/","title":"Client","text":""},{"location":"api_reference/client/#penne.Client","title":"penne.Client","text":"<pre><code>Client(url, custom_delegate_hash=None, on_connected=None, strict=False, json=None)\n</code></pre> <p>             Bases: <code>object</code></p> <p>Client for communicating with server</p> <p>Attributes:</p> Name Type Description <code>_url</code> <code>string</code> <p>address used to connect to server</p> <code>_loop</code> <code>event loop</code> <p>event loop used for network thread</p> <code>delegates</code> <code>dict</code> <p>map for delegate functions</p> <code>thread</code> <code>thread object</code> <p>network thread used by client</p> <code>_socket</code> <code>WebSocketClientProtocol</code> <p>socket to connect to server</p> <code>name</code> <code>str</code> <p>name of the client</p> <code>state</code> <code>dict</code> <p>dict keeping track of created objects</p> <code>client_message_map</code> <code>dict</code> <p>mapping message type to corresponding id</p> <code>server_messages</code> <code>dict</code> <p>mapping message id's to handle info</p> <code>_current_invoke</code> <code>str</code> <p>id for next method invoke</p> <code>callback_map</code> <code>dict</code> <p>mapping invoke_id to callback function</p> <code>callback_queue</code> <code>queue</code> <p>queue for storing callback functions, useful for polling and running in the main thread</p> <code>is_active</code> <code>bool</code> <p>flag for whether client is active</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>string</code> <p>address used to connect to server</p> required <code>custom_delegate_hash</code> <code>dict</code> <p>map for new delegates to be used on client</p> <code>None</code> <code>on_connected</code> <code>Callable</code> <p>callback function to run once client is set up</p> <code>None</code> <code>strict</code> <code>bool</code> <p>flag for strict data validation and throwing hard exceptions</p> <code>False</code> <code>json</code> <code>str</code> <p>path for outputting json log of messages</p> <code>None</code> Source code in <code>penne/core.py</code> <pre><code>def __init__(self, url: str, custom_delegate_hash: dict[Type[delegates.Delegate], Type[delegates.Delegate]] = None,\n             on_connected=None, strict=False, json=None):\n\"\"\"Constructor for the Client Class\n\n    Args:\n        url (string):\n            address used to connect to server\n        custom_delegate_hash (dict):\n            map for new delegates to be used on client\n        on_connected (Callable):\n            callback function to run once client is set up\n        strict (bool):\n            flag for strict data validation and throwing hard exceptions\n        json (str):\n            path for outputting json log of messages\n    \"\"\"\n\n    if not custom_delegate_hash:\n        custom_delegate_hash = {}\n\n    self._url = url\n    self._loop = asyncio.new_event_loop()\n    self.on_connected = on_connected\n    self.delegates = delegates.default_delegates.copy()\n    self.strict = strict\n    self.thread = threading.Thread(target=self._start_communication_thread)\n    self.connection_established = threading.Event()\n    self._socket = None\n    self.name = \"Python Client\"\n    self.state = {}\n    self.client_message_map = {\n        \"intro\": 0,\n        \"invoke\": 1\n    }\n    self.server_messages = [\n        HandleInfo(delegates.Method, \"create\"),\n        HandleInfo(delegates.Method, \"delete\"),\n        HandleInfo(delegates.Signal, \"create\"),\n        HandleInfo(delegates.Signal, \"delete\"),\n        HandleInfo(delegates.Entity, \"create\"),\n        HandleInfo(delegates.Entity, \"update\"),\n        HandleInfo(delegates.Entity, \"delete\"),\n        HandleInfo(delegates.Plot, \"create\"),\n        HandleInfo(delegates.Plot, \"update\"),\n        HandleInfo(delegates.Plot, \"delete\"),\n        HandleInfo(delegates.Buffer, \"create\"),\n        HandleInfo(delegates.Buffer, \"delete\"),\n        HandleInfo(delegates.BufferView, \"create\"),\n        HandleInfo(delegates.BufferView, \"delete\"),\n        HandleInfo(delegates.Material, \"create\"),\n        HandleInfo(delegates.Material, \"update\"),\n        HandleInfo(delegates.Material, \"delete\"),\n        HandleInfo(delegates.Image, \"create\"),\n        HandleInfo(delegates.Image, \"delete\"),\n        HandleInfo(delegates.Texture, \"create\"),\n        HandleInfo(delegates.Texture, \"delete\"),\n        HandleInfo(delegates.Sampler, \"create\"),\n        HandleInfo(delegates.Sampler, \"delete\"),\n        HandleInfo(delegates.Light, \"create\"),\n        HandleInfo(delegates.Light, \"update\"),\n        HandleInfo(delegates.Light, \"delete\"),\n        HandleInfo(delegates.Geometry, \"create\"),\n        HandleInfo(delegates.Geometry, \"delete\"),\n        HandleInfo(delegates.Table, \"create\"),\n        HandleInfo(delegates.Table, \"update\"),\n        HandleInfo(delegates.Table, \"delete\"),\n        HandleInfo(delegates.Document, \"update\"),\n        HandleInfo(delegates.Document, \"reset\"),\n        HandleInfo(delegates.Signal, \"invoke\"),\n        HandleInfo(delegates.Method, \"reply\"),\n        HandleInfo(delegates.Document, \"initialized\")\n    ]\n    self._current_invoke = 0\n    self.callback_map = {}\n    self.callback_queue = queue.Queue()\n    self.is_active = False\n    self.json = json\n    if json:\n        with open(json, \"w\") as outfile:  # Clear out old contents\n            outfile.write(\"JSON Log\\n\")\n\n    # Hook up delegate map to customs\n    self.delegates.update(custom_delegate_hash)\n\n    # Add document delegate as starting element in state\n    self.state[\"document\"] = self.delegates[delegates.Document](client=self)\n</code></pre>"},{"location":"api_reference/client/#penne.Client.get_delegate","title":"get_delegate","text":"<pre><code>get_delegate(identifier)\n</code></pre> <p>Getter to easily retrieve components from state</p> <p>Accepts multiple types of identifiers for flexibility</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>ID | str | dict</code> <p>id, name, or context for the component</p> required <p>Returns:</p> Name Type Description <code>Delegate</code> <code>Delegate</code> <p>delegate object from state</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if identifier is not a valid type</p> <code>KeyError</code> <p>if id or name is not found in state</p> <code>ValueError</code> <p>if context is not found in state</p> Source code in <code>penne/core.py</code> <pre><code>def get_delegate(self, identifier: Union[delegates.ID, str, Dict[str, delegates.ID]]) -&gt; Type[delegates.Delegate]:\n\"\"\"Getter to easily retrieve components from state\n\n    Accepts multiple types of identifiers for flexibility\n\n    Args:\n        identifier (ID | str | dict): id, name, or context for the component\n\n    Returns:\n        Delegate (Delegate): delegate object from state\n\n    Raises:\n        TypeError: if identifier is not a valid type\n        KeyError: if id or name is not found in state\n        ValueError: if context is not found in state\n    \"\"\"\n    if isinstance(identifier, delegates.ID):\n        return self.state[identifier]\n    elif isinstance(identifier, str):\n        return self.state[self.get_delegate_id(identifier)]\n    elif isinstance(identifier, dict):\n        return self.get_delegate_by_context(identifier)\n    else:\n        raise TypeError(f\"Invalid type for identifier: {type(identifier)}\")\n</code></pre>"},{"location":"api_reference/client/#penne.Client.get_delegate_by_context","title":"get_delegate_by_context","text":"<pre><code>get_delegate_by_context(context=None)\n</code></pre> <p>Get delegate object from a context object</p> <p>Contexts are of the form {\"table\": TableID}, {\"entity\": EntityID}, or {\"plot\": PlotID}. They are only applicable for tables, entities, and plots</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>dict containing context</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Delegate</code> <code>Delegate</code> <p>delegate object from state</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Couldn't get delegate from context</p> Source code in <code>penne/core.py</code> <pre><code>def get_delegate_by_context(self, context: dict = None) -&gt; delegates.Delegate:\n\"\"\"Get delegate object from a context object\n\n    Contexts are of the form {\"table\": TableID}, {\"entity\": EntityID}, or {\"plot\": PlotID}.\n    They are only applicable for tables, entities, and plots\n\n    Args:\n        context (dict): dict containing context\n\n    Returns:\n        Delegate (Delegate): delegate object from state\n\n    Raises:\n        ValueError: Couldn't get delegate from context\n    \"\"\"\n\n    if not context:\n        target_delegate = self.state[\"document\"]\n        return target_delegate\n\n    table = context.get(\"table\")\n    entity = context.get(\"entity\")\n    plot = context.get(\"plot\")\n\n    if table:\n        target_delegate = self.state[delegates.TableID(*table)]\n    elif entity:\n        target_delegate = self.state[delegates.EntityID(*entity)]\n    elif plot:\n        target_delegate = self.state[delegates.PlotID(*plot)]\n    else:\n        raise ValueError(\"Couldn't get delegate from context\")\n\n    return target_delegate\n</code></pre>"},{"location":"api_reference/client/#penne.Client.get_delegate_id","title":"get_delegate_id","text":"<pre><code>get_delegate_id(name)\n</code></pre> <p>Get a delegate's id from its name. Assumes names are unique, or returns the first match</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of method</p> required <p>Returns:</p> Name Type Description <code>ID</code> <code>ID</code> <p>ID for the delegate</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if no match is found</p> Source code in <code>penne/core.py</code> <pre><code>def get_delegate_id(self, name: str) -&gt; Type[delegates.ID]:\n\"\"\"Get a delegate's id from its name. Assumes names are unique, or returns the first match\n\n    Args:\n        name (str): name of method\n\n    Returns:\n        ID (ID): ID for the delegate\n\n    Raises:\n        KeyError: if no match is found\n    \"\"\"\n    if name == \"document\":\n        return name\n\n    state_delegates = self.state.values()\n    for delegate in state_delegates:\n        if delegate.name == name:\n            return delegate.id\n    raise KeyError(f\"Couldn't find object '{name}' in state\")\n</code></pre>"},{"location":"api_reference/client/#penne.Client.invoke_method","title":"invoke_method","text":"<pre><code>invoke_method(method, args=None, context=None, callback=None)\n</code></pre> <p>Invoke method on server</p> <p>Constructs a dictionary of arguments to use in send_message. The Dictionary follows the structure of an InvokeMethodMessage, but using a dictionary prevents from converting back and forth just before sending.</p> <p>Also implements callback functions attached to each invocation. By default, each invocation will store a None object in the callback map, and the handler responsible for reply messages will delete pop it from the map and call the method if there is one</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>ID | str</code> <p>id or name for method</p> required <code>args</code> <code>list</code> <p>arguments for method</p> <code>None</code> <code>context</code> <code>dict</code> <p>optional, target context for method call</p> <code>None</code> <code>callback</code> <code>Callable</code> <p>function to be called upon response</p> <code>None</code> <p>Returns:</p> Name Type Description <code>message</code> <code>list</code> <p>message to be sent to server in the form of [tag, {content}]</p> Source code in <code>penne/core.py</code> <pre><code>def invoke_method(self, method: Union[delegates.MethodID, str], args: list = None,\n                  context: dict[str, tuple] = None, callback=None):\n\"\"\"Invoke method on server\n\n    Constructs a dictionary of arguments to use in send_message. The\n    Dictionary follows the structure of an InvokeMethodMessage, but\n    using a dictionary prevents from converting back and forth just\n    before sending.\n\n    Also implements callback functions attached to each invocation. By\n    default, each invocation will store a None object in the callback\n    map, and the handler responsible for reply messages will delete pop\n    it from the map and call the method if there is one\n\n    Args:\n        method (ID | str):\n            id or name for method\n        args (list): \n            arguments for method\n        context (dict): \n            optional, target context for method call\n        callback (Callable):\n            function to be called upon response\n\n    Returns:\n        message (list): message to be sent to server in the form of [tag, {content}]\n    \"\"\"\n\n    # Handle default args\n    if not args:\n        args = []\n\n    # Get proper ID\n    if isinstance(method, str):\n        method_id = self.get_delegate_id(method)\n    else:\n        method_id = method\n\n    # Get invoke ID\n    invoke_id = str(self._current_invoke)\n    self._current_invoke += 1\n\n    # Keep track of callback\n    self.callback_map[invoke_id] = callback\n\n    # Construct message dict\n    arg_dict = {\n        \"method\": method_id,\n        \"args\": args,\n        \"invoke_id\": invoke_id\n    }\n    if context:\n        arg_dict[\"context\"] = context\n\n    return self.send_message(arg_dict, \"invoke\")\n</code></pre>"},{"location":"api_reference/client/#penne.Client.send_message","title":"send_message","text":"<pre><code>send_message(message_dict, kind)\n</code></pre> <p>Send message to server</p> <p>Parameters:</p> Name Type Description Default <code>message_dict</code> <code>dict</code> <p>dict mapping message attribute to value</p> required <code>kind</code> <code>str</code> <p>either 'invoke' or 'intro' to indicate type of client message</p> required Source code in <code>penne/core.py</code> <pre><code>def send_message(self, message_dict: dict[str, Any], kind: str):\n\"\"\"Send message to server\n\n    Args:\n        message_dict (dict): dict mapping message attribute to value\n        kind (str): either 'invoke' or 'intro' to indicate type of client message\n    \"\"\"\n\n    # Construct message with ID from map and converted message object\n    message = [self.client_message_map[kind], message_dict]\n    if self.json:\n        self._log_json(message)\n\n    logging.debug(f\"Sending Message: {message}\")\n    asyncio.run_coroutine_threadsafe(self._socket.send(dumps(message)), self._loop)\n    return message\n</code></pre>"},{"location":"api_reference/client/#penne.Client.show_methods","title":"show_methods","text":"<pre><code>show_methods()\n</code></pre> <p>Displays Available Methods to the User on the document</p> <p>Uses the document delegate's show_methods function to display</p> Source code in <code>penne/core.py</code> <pre><code>def show_methods(self):\n\"\"\"Displays Available Methods to the User on the document\n\n    Uses the document delegate's show_methods function to display\n    \"\"\"\n    self.state[\"document\"].show_methods()\n</code></pre>"},{"location":"api_reference/client/#penne.Client.shutdown","title":"shutdown","text":"<pre><code>shutdown()\n</code></pre> <p>Method for shutting down the client</p> <p>Closes websocket connection then blocks to finish all callbacks, joins thread as well</p> Source code in <code>penne/core.py</code> <pre><code>def shutdown(self):\n\"\"\"Method for shutting down the client\n\n    Closes websocket connection then blocks to finish all callbacks, joins thread as well\n    \"\"\"\n    asyncio.run_coroutine_threadsafe(self._socket.close(), self._loop)\n    self.is_active = False\n    self.thread.join()\n</code></pre>"},{"location":"api_reference/delegates/","title":"Delegates","text":""},{"location":"api_reference/delegates/#penne.Delegate","title":"penne.Delegate","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Parent class for all delegates</p> <p>Defines general methods that should be available for all delegates. In this context, a delegate refers to an object in a NOODLES scene that can be subclassed and extended by the user. For example, a user can create an implementation for a table that specifically suits their needs. The server's job is essentially to manage the state of all delegates, and to call the appropriate methods on them when necessary. Most methods defined by the user will also be to manipulate the state of the delegates.</p> <p>Attributes:</p> Name Type Description <code>client</code> <code>Client</code> <p>Client delegate is attached to</p> <code>id</code> <code>ID</code> <p>Unique identifier for delegate</p> <code>name</code> <code>str</code> <p>Name of delegate</p> <code>signals</code> <code>dict</code> <p>Signals that can be called on delegate, method name to callable</p>"},{"location":"api_reference/delegates/#penne.InjectedMethod","title":"penne.InjectedMethod","text":"<pre><code>InjectedMethod(method_obj)\n</code></pre> <p>             Bases: <code>object</code></p> <p>Class for representing injected method in delegate</p> <p>The context is automatically set when invoked. This object is callable and is what is actually called when the injected method is called.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>Callable</code> <p>method to be called</p> <code>injected</code> <code>bool</code> <p>attribute marking method as injected, useful for clearing out old injected methods</p> Source code in <code>penne/delegates.py</code> <pre><code>def __init__(self, method_obj) -&gt; None:\n    self.method = method_obj\n    self.injected = True\n</code></pre>"},{"location":"api_reference/delegates/#penne.inject_methods","title":"penne.inject_methods","text":"<pre><code>inject_methods(delegate, methods)\n</code></pre> <p>Inject methods into a delegate class</p> <p>Idea is to inject a method that is from the server to put into a delegate. Now it looks like the delegate has an instance method that actually calls what is on the server. Context, is automatically taken care of. This should mostly be called on_new or on_update for delegates that have methods. This method clears out any old injected methods if present.</p> <p>Parameters:</p> Name Type Description Default <code>delegate</code> <code>Delegate</code> <p>identifier for delegate to be modified</p> required <code>methods</code> <code>list</code> <p>list of method id's to inject</p> required Source code in <code>penne/delegates.py</code> <pre><code>def inject_methods(delegate: Delegate, methods: List[MethodID]):\n\"\"\"Inject methods into a delegate class\n\n    Idea is to inject a method that is from the server to put into a delegate.\n    Now it looks like the delegate has an instance method that actually calls what\n    is on the server. Context, is automatically taken care of. This should mostly be\n    called on_new or on_update for delegates that have methods. This method clears out any\n    old injected methods if present.\n\n    Args:\n        delegate (Delegate):\n            identifier for delegate to be modified\n        methods (list):\n            list of method id's to inject\n    \"\"\"\n\n    # Clear out old injected methods\n    to_remove = []\n    for field, value in delegate:\n        if hasattr(value, \"injected\"):\n            logging.debug(f\"Deleting: {field} in inject methods\")\n            to_remove.append(field)\n    for field in to_remove:\n        delattr(delegate, field)\n\n    for method_id in methods:\n\n        # Get method delegate and manipulate name to exclude noo::\n        method = delegate.client.get_delegate(method_id)\n        if \"noo::\" in method.name:\n            name = method.name[5:]\n        else:\n            name = method.name\n\n        # Create injected by linking delegates, and creating call method\n        linked = LinkedMethod(delegate, method)\n        injected = InjectedMethod(linked.__call__)\n\n        setattr(delegate, name, injected)\n</code></pre>"},{"location":"api_reference/delegates/#penne.inject_signals","title":"penne.inject_signals","text":"<pre><code>inject_signals(delegate, signals)\n</code></pre> <p>Method to inject signals into delegate</p> <p>Idea is to inject a signal that is from the server to put into a delegate. These signals are stored in a dict that can be used to map the signal name to a callable response that handles the signal and its args.</p> <p>Parameters:</p> Name Type Description Default <code>delegate</code> <code>Delegate</code> <p>delegate object to be injected</p> required <code>signals</code> <code>list</code> <p>list of signal id's to be injected</p> required Source code in <code>penne/delegates.py</code> <pre><code>def inject_signals(delegate: Delegate, signals: List[SignalID]):\n\"\"\"Method to inject signals into delegate\n\n    Idea is to inject a signal that is from the server to put into a delegate. These signals are stored in a dict\n    that can be used to map the signal name to a callable response that handles the signal and its args.\n\n    Args:\n        delegate (Delegate):\n            delegate object to be injected\n        signals (list):\n            list of signal id's to be injected\n    \"\"\"\n\n    for signal_id in signals:\n        signal = delegate.client.state[signal_id]  # refactored state\n        delegate.signals[signal.name] = None\n</code></pre>"},{"location":"api_reference/delegates/#penne.get_context","title":"penne.get_context","text":"<pre><code>get_context(delegate)\n</code></pre> <p>Helper to get context from delegate</p> <p>Parameters:</p> Name Type Description Default <code>delegate</code> <code>Delegate</code> <p>delegate to get context for, can be Entity, Table, or Plot</p> required <p>Returns:</p> Name Type Description <code>context</code> <code>dict</code> <p>context for delegate, None if not found indicating document</p> Source code in <code>penne/delegates.py</code> <pre><code>def get_context(delegate: Delegate):\n\"\"\"Helper to get context from delegate\n\n    Args:\n        delegate (Delegate): delegate to get context for, can be Entity, Table, or Plot\n\n    Returns:\n        context (dict): context for delegate, None if not found indicating document\n\n    \"\"\"\n\n    if isinstance(delegate, Entity):\n        return {\"entity\": delegate.id}\n    elif isinstance(delegate, Table):\n        return {\"table\": delegate.id}\n    elif isinstance(delegate, Plot):\n        return {\"plot\": delegate.id}\n    else:\n        return None\n</code></pre>"},{"location":"api_reference/delegates/#penne.Method","title":"penne.Method","text":"<p>             Bases: <code>Delegate</code></p> <p>A method that clients can request the server to call.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>MethodID</code> <p>ID for the method</p> <code>name</code> <code>str</code> <p>Name of the method</p> <code>doc</code> <code>Optional[str]</code> <p>Documentation for the method</p> <code>return_doc</code> <code>Optional[str]</code> <p>Documentation for the return value</p> <code>arg_doc</code> <code>List[MethodArg]</code> <p>Documentation for the arguments</p>"},{"location":"api_reference/delegates/#penne.Method.invoke","title":"invoke","text":"<pre><code>invoke(on_delegate, args=None, callback=None)\n</code></pre> <p>Invoke this delegate's method</p> <p>Parameters:</p> Name Type Description Default <code>on_delegate</code> <code>Delegate</code> <p>delegate method is being invoked on  used to get context</p> required <code>args</code> <code>list</code> <p>args for the method</p> <code>None</code> <code>callback</code> <code>function</code> <p>function to be called when complete</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid delegate context</p> Source code in <code>penne/delegates.py</code> <pre><code>def invoke(self, on_delegate: Delegate, args=None, callback=None):\n\"\"\"Invoke this delegate's method\n\n    Args:\n        on_delegate (Delegate):\n            delegate method is being invoked on \n            used to get context\n        args (list, optional):\n            args for the method\n        callback (function):\n            function to be called when complete\n\n    Raises:\n        ValueError: Invalid delegate context\n    \"\"\"\n\n    if isinstance(on_delegate, Table):\n        kind = \"table\"\n    elif isinstance(on_delegate, Plot):\n        kind = \"plot\"\n    elif isinstance(on_delegate, Entity):\n        kind = \"entity\"\n    else:\n        raise ValueError(\"Invalid delegate context\")\n\n    context = {kind: on_delegate.id}\n    self.client.invoke_method(self.id, args, context=context, callback=callback)\n</code></pre>"},{"location":"api_reference/delegates/#penne.Signal","title":"penne.Signal","text":"<p>             Bases: <code>Delegate</code></p> <p>A signal that the server can send to update clients.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>SignalID</code> <p>ID for the signal</p> <code>name</code> <code>str</code> <p>Name of the signal</p> <code>doc</code> <code>Optional[str]</code> <p>Documentation for the signal</p> <code>arg_doc</code> <code>List[MethodArg]</code> <p>Documentation for the arguments</p>"},{"location":"api_reference/delegates/#penne.Entity","title":"penne.Entity","text":"<p>             Bases: <code>Delegate</code></p> <p>Container for other entities, possibly renderable, has associated methods and signals</p> <p>Can reference other entities, geometry, plots, and lights. It can be rendered, if it has a render rep. It may have associated methods and signals. The transform is relative to the parent entity. In other contexts it may be called a node.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>EntityID</code> <p>ID for the entity</p> <code>name</code> <code>Optional[str]</code> <p>Name of the entity</p> <code>parent</code> <code>Optional[EntityID]</code> <p>Parent entity</p> <code>transform</code> <code>Optional[Mat4]</code> <p>Local transform for the entity</p> <code>text_rep</code> <code>Optional[TextRepresentation]</code> <p>Text representation for the entity</p> <code>web_rep</code> <code>Optional[WebRepresentation]</code> <p>Web representation for the entity</p> <code>render_rep</code> <code>Optional[RenderRepresentation]</code> <p>Render representation for the entity</p> <code>lights</code> <code>Optional[List[LightID]]</code> <p>List of lights attached to the entity</p> <code>tables</code> <code>Optional[List[TableID]]</code> <p>List of tables attached to the entity</p> <code>plots</code> <code>Optional[List[PlotID]]</code> <p>List of plots attached to the entity</p> <code>tags</code> <code>Optional[List[str]]</code> <p>List of tags for the entity</p> <code>methods_list</code> <code>Optional[List[MethodID]]</code> <p>List of methods attached to the entity</p> <code>signals_list</code> <code>Optional[List[SignalID]]</code> <p>List of signals attached to the entity</p> <code>influence</code> <code>Optional[BoundingBox]</code> <p>Bounding box for the entity</p>"},{"location":"api_reference/delegates/#penne.Entity.request_set_position","title":"request_set_position","text":"<pre><code>request_set_position(position)\n</code></pre> <p>Request to set the position of the entity</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Vec3</code> <p>Position to set</p> required Source code in <code>penne/delegates.py</code> <pre><code>def request_set_position(self, position: Vec3):\n\"\"\"Request to set the position of the entity\n\n    Args:\n        position (Vec3): Position to set\n    \"\"\"\n    self.set_position(position)\n</code></pre>"},{"location":"api_reference/delegates/#penne.Entity.request_set_rotation","title":"request_set_rotation","text":"<pre><code>request_set_rotation(rotation)\n</code></pre> <p>Request to set the rotation of the entity</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>Vec4</code> <p>Rotation to set</p> required Source code in <code>penne/delegates.py</code> <pre><code>def request_set_rotation(self, rotation: Vec4):\n\"\"\"Request to set the rotation of the entity\n\n    Args:\n        rotation (Vec4): Rotation to set\n    \"\"\"\n    self.set_rotation(rotation)\n</code></pre>"},{"location":"api_reference/delegates/#penne.Entity.request_set_scale","title":"request_set_scale","text":"<pre><code>request_set_scale(scale)\n</code></pre> <p>Request to set the scale of the entity</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>Vec3</code> <p>Scale to set</p> required Source code in <code>penne/delegates.py</code> <pre><code>def request_set_scale(self, scale: Vec3):\n\"\"\"Request to set the scale of the entity\n\n    Args:\n        scale (Vec3): Scale to set\n    \"\"\"\n    self.set_scale(scale)\n</code></pre>"},{"location":"api_reference/delegates/#penne.Entity.show_methods","title":"show_methods","text":"<pre><code>show_methods()\n</code></pre> <p>Show methods available on the entity</p> Source code in <code>penne/delegates.py</code> <pre><code>def show_methods(self):\n\"\"\"Show methods available on the entity\"\"\"\n\n    if self.methods_list is None:\n        message = \"No methods available\"\n    else:\n        message = f\"-- Methods on {self.name} --\\n--------------------------------------\\n\"\n        for method_id in self.methods_list:\n            method = self.client.get_delegate(method_id)\n            message += f\"&gt;&gt; {method}\"\n\n    print(message)\n    return message\n</code></pre>"},{"location":"api_reference/delegates/#penne.Plot","title":"penne.Plot","text":"<p>             Bases: <code>Delegate</code></p> <p>An abstract plot object.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>PlotID</code> <p>ID for the plot</p> <code>name</code> <code>Optional[str]</code> <p>Name of the plot</p> <code>table</code> <code>Optional[TableID]</code> <p>Table to plot</p> <code>simple_plot</code> <code>Optional[str]</code> <p>Simple plot to render</p> <code>url_plot</code> <code>Optional[str]</code> <p>URL for plot to render</p> <code>methods_list</code> <code>Optional[List[MethodID]]</code> <p>List of methods attached to the plot</p> <code>signals_list</code> <code>Optional[List[SignalID]]</code> <p>List of signals attached to the plot</p>"},{"location":"api_reference/delegates/#penne.Plot.show_methods","title":"show_methods","text":"<pre><code>show_methods()\n</code></pre> <p>Show methods available on the entity</p> Source code in <code>penne/delegates.py</code> <pre><code>def show_methods(self):\n\"\"\"Show methods available on the entity\"\"\"\n\n    if self.methods_list is None:\n        message = \"No methods available\"\n    else:\n        message = f\"-- Methods on {self.name} --\\n--------------------------------------\\n\"\n        for method_id in self.methods_list:\n            method = self.client.get_delegate(method_id)\n            message += f\"&gt;&gt; {method}\"\n\n    print(message)\n    return message\n</code></pre>"},{"location":"api_reference/delegates/#penne.Buffer","title":"penne.Buffer","text":"<p>             Bases: <code>Delegate</code></p> <p>A buffer of bytes containing data for an image or a mesh.</p> <p>Bytes can be stored directly in the buffer with inline_bytes, or they can be stored in a URI with uri_bytes. The server should create a separate server to host the bytes, and there is support for this in the ByteServer class. To obtain these bytes, clients would have to make an HTTP request to the URI.</p> <p>A buffer could store a single attribute, or it could store multiple attributes interleaved together. This is where buffer views specify how to interpret the buffer.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>BufferID</code> <p>ID for the buffer</p> <code>name</code> <code>Optional[str]</code> <p>Name of the buffer</p> <code>size</code> <code>int</code> <p>Size of the buffer in bytes</p> <code>inline_bytes</code> <code>Optional[bytes]</code> <p>Bytes of the buffer</p> <code>uri_bytes</code> <code>Optional[str]</code> <p>URI for the bytes</p>"},{"location":"api_reference/delegates/#penne.BufferView","title":"penne.BufferView","text":"<p>             Bases: <code>Delegate</code></p> <p>A view into a buffer, specifying a subset of the buffer and how to interpret it.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>BufferViewID</code> <p>ID for the buffer view</p> <code>name</code> <code>Optional[str]</code> <p>Name of the buffer view</p> <code>source_buffer</code> <code>BufferID</code> <p>Buffer that the view is referring to</p> <code>type</code> <code>BufferType</code> <p>Type of the buffer view</p> <code>offset</code> <code>int</code> <p>Offset into the buffer in bytes</p> <code>length</code> <code>int</code> <p>Length of the buffer view in bytes</p>"},{"location":"api_reference/delegates/#penne.Material","title":"penne.Material","text":"<p>             Bases: <code>Delegate</code></p> <p>A material that can be applied to a mesh.</p> <p>The material is a collection of textures and factors that are used to render the mesh.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>MaterialID</code> <p>ID for the material</p> <code>name</code> <code>Optional[str]</code> <p>Name of the material</p> <code>pbr_info</code> <code>Optional[PBRInfo]</code> <p>Information for physically based rendering</p> <code>normal_texture</code> <code>Optional[TextureRef]</code> <p>Texture for normals</p> <code>occlusion_texture</code> <code>Optional[TextureRef]</code> <p>Texture for occlusion</p> <code>occlusion_texture_factor</code> <code>Optional[float]</code> <p>Factor for occlusion</p> <code>emissive_texture</code> <code>Optional[TextureRef]</code> <p>Texture for emissive</p> <code>emissive_factor</code> <code>Optional[Vec3]</code> <p>Factor for emissive</p> <code>use_alpha</code> <code>Optional[bool]</code> <p>Whether to use alpha</p> <code>alpha_cutoff</code> <code>Optional[float]</code> <p>Alpha cutoff</p> <code>double_sided</code> <code>Optional[bool]</code> <p>Whether the material is double-sided</p>"},{"location":"api_reference/delegates/#penne.Image","title":"penne.Image","text":"<p>             Bases: <code>Delegate</code></p> <p>An image, can be used for a texture</p> <p>Like a buffer, an image can be stored in a URI to reduce the size of messages. To obtain the bytes, you would have to make an HTTP request to the URI.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>ImageID</code> <p>ID for the image</p> <code>name</code> <code>Optional[str]</code> <p>Name of the image</p> <code>buffer_source</code> <code>Optional[BufferID]</code> <p>Buffer that the image is stored in</p> <code>uri_source</code> <code>Optional[str]</code> <p>URI for the bytes if they are hosted externally</p>"},{"location":"api_reference/delegates/#penne.Texture","title":"penne.Texture","text":"<p>             Bases: <code>Delegate</code></p> <p>A texture, can be used for a material</p> <p>This is like a wrapping paper that is applied to a mesh. The image specifies the pattern, and the sampler specifies which part of the image should be applied to each part of the mesh.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TextureID</code> <p>ID for the texture</p> <code>name</code> <code>Optional[str]</code> <p>Name of the texture</p> <code>image</code> <code>ImageID</code> <p>Image to use for the texture</p> <code>sampler</code> <code>Optional[SamplerID]</code> <p>Sampler to use for the texture</p>"},{"location":"api_reference/delegates/#penne.Sampler","title":"penne.Sampler","text":"<p>             Bases: <code>Delegate</code></p> <p>A sampler to use for a texture</p> <p>A sampler specifies how to take portions of an image and apply them to a mesh.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>SamplerID</code> <p>ID for the sampler</p> <code>name</code> <code>Optional[str]</code> <p>Name of the sampler</p> <code>mag_filter</code> <code>Optional[MagFilterTypes]</code> <p>Magnification filter</p> <code>min_filter</code> <code>Optional[MinFilterTypes]</code> <p>Minification filter</p> <code>wrap_s</code> <code>Optional[SamplerMode]</code> <p>Wrap mode for S</p> <code>wrap_t</code> <code>Optional[SamplerMode]</code> <p>Wrap mode for T</p>"},{"location":"api_reference/delegates/#penne.Light","title":"penne.Light","text":"<p>             Bases: <code>Delegate</code></p> <p>Represents a light in the scene</p> <p>For these purposes, a light is just a couple of properties like color, intensity, and light type. The entity that stores the light will dictate position and direction with its transform. The client application is then responsible for using this information to render the light. The light is either a point light, a spotlight, or a directional light.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>LightID</code> <p>ID for the light</p> <code>name</code> <code>Optional[str]</code> <p>Name of the light</p> <code>color</code> <code>Optional[Color]</code> <p>Color of the light</p> <code>intensity</code> <code>Optional[float]</code> <p>Intensity of the light</p> <code>point</code> <code>Optional[PointLight]</code> <p>Point light information</p> <code>spot</code> <code>Optional[SpotLight]</code> <p>Spotlight information</p> <code>directional</code> <code>Optional[DirectionalLight]</code> <p>Directional light information</p>"},{"location":"api_reference/delegates/#penne.Geometry","title":"penne.Geometry","text":"<p>             Bases: <code>Delegate</code></p> <p>Represents geometry in the scene and can be used for meshes</p> <p>This is more of a collection of patches, but each patch will contain the geometry information to render a mesh. The patch references buffer views and buffers for each attribute, and a material to use for rendering. Instances are stored in a separate buffer that is referenced at the entity level.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>GeometryID</code> <p>ID for the geometry</p> <code>name</code> <code>Optional[str]</code> <p>Name of the geometry</p> <code>patches</code> <code>List[GeometryPatch]</code> <p>Patches that make up the geometry</p>"},{"location":"api_reference/delegates/#penne.Table","title":"penne.Table","text":"<pre><code>Table(**kwargs)\n</code></pre> <p>             Bases: <code>Delegate</code></p> <p>Object to store tabular data.</p> <p>Note that this delegate doesn't store any actual data. Delegates are meant to subclass and add functionality to this class. For the client to receive the actual data, they must subscribe to the table. The client will have access to certain injected methods that allow them to insert, update, delete, and clear the table. This class provides some abstract methods that can be overridden to handle these events.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TableID</code> <p>ID for the table</p> <code>name</code> <code>Optional[str]</code> <p>Name of the table</p> <code>meta</code> <code>Optional[str]</code> <p>Metadata for the table</p> <code>methods_list</code> <code>Optional[List[MethodID]]</code> <p>List of methods for the table</p> <code>signals_list</code> <code>Optional[List[SignalID]]</code> <p>List of signals for the table</p> <code>tbl_subscribe</code> <code>Optional[InjectedMethod]</code> <p>Injected method to subscribe to the table</p> <code>tbl_insert</code> <code>Optional[InjectedMethod]</code> <p>Injected method to insert rows into the table</p> <code>tbl_update</code> <code>Optional[InjectedMethod]</code> <p>Injected method to update rows in the table</p> <code>tbl_remove</code> <code>Optional[InjectedMethod]</code> <p>Injected method to remove rows from the table</p> <code>tbl_clear</code> <code>Optional[InjectedMethod]</code> <p>Injected method to clear the table</p> <code>tbl_update_selection</code> <code>Optional[InjectedMethod]</code> <p>Injected method to update the selection</p> Source code in <code>penne/delegates.py</code> <pre><code>def __init__(self, **kwargs):\n\"\"\"Override init to link default values with methods\"\"\"\n    super().__init__(**kwargs)\n    self.signals = {\n        \"noo::tbl_reset\": self._reset_table,\n        \"noo::tbl_rows_removed\": self._remove_rows,\n        \"noo::tbl_updated\": self._update_rows,\n        \"noo::tbl_selection_updated\": self._update_selection\n    }\n</code></pre>"},{"location":"api_reference/delegates/#penne.Table.on_new","title":"on_new","text":"<pre><code>on_new(message)\n</code></pre> <p>Handler when create message is received</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>create message with the table's info</p> required Source code in <code>penne/delegates.py</code> <pre><code>def on_new(self, message: dict):\n\"\"\"Handler when create message is received\n\n    Args:\n        message (Message): create message with the table's info\n    \"\"\"\n\n    # Check contents\n    methods = self.methods_list\n    signals = self.signals_list\n\n    # Inject methods and signals if applicable\n    if methods:\n        inject_methods(self, methods)\n    if signals:\n        inject_signals(self, signals)\n\n    # Reset\n    self._reset_table()\n    self.relink_signals()\n</code></pre>"},{"location":"api_reference/delegates/#penne.Table.on_update","title":"on_update","text":"<pre><code>on_update(message)\n</code></pre> <p>Handler when update message is received</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>update message with the new table's info</p> required Source code in <code>penne/delegates.py</code> <pre><code>def on_update(self, message: dict):\n\"\"\"Handler when update message is received\n\n    Args:\n        message (Message): update message with the new table's info\n    \"\"\"\n\n    # Inject methods and signals if applicable\n    if self.methods_list:\n        inject_methods(self, self.methods_list)\n    if self.signals_list:\n        inject_signals(self, self.signals_list)\n    self.relink_signals()\n</code></pre>"},{"location":"api_reference/delegates/#penne.Table.relink_signals","title":"relink_signals","text":"<pre><code>relink_signals()\n</code></pre> <p>Relink the signals for built-in methods</p> <p>Injecting signals adds them as keys which map to None. The signals must be relinked after injecting. These should always be linked, along with whatever is injected.</p> Source code in <code>penne/delegates.py</code> <pre><code>def relink_signals(self):\n\"\"\"Relink the signals for built-in methods\n\n    Injecting signals adds them as keys which map to None. The signals must be relinked after injecting.\n    These should always be linked, along with whatever is injected.\n    \"\"\"\n\n    self.signals[\"noo::tbl_reset\"] = self._reset_table\n    self.signals[\"noo::tbl_rows_removed\"] = self._remove_rows\n    self.signals[\"noo::tbl_updated\"] = self._update_rows\n    self.signals[\"noo::tbl_selection_updated\"] = self._update_selection\n</code></pre>"},{"location":"api_reference/delegates/#penne.Table.request_clear","title":"request_clear","text":"<pre><code>request_clear(callback=None)\n</code></pre> <p>Clear the table</p> <p>User endpoint for interacting with table and invoking method</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>function</code> <p>callback function called when complete</p> <code>None</code> Source code in <code>penne/delegates.py</code> <pre><code>def request_clear(self, callback=None):\n\"\"\"Clear the table\n\n    User endpoint for interacting with table and invoking method\n\n    Args:\n        callback (function, optional): callback function called when complete\n    \"\"\"\n    self.tbl_clear(callback=callback)\n</code></pre>"},{"location":"api_reference/delegates/#penne.Table.request_insert","title":"request_insert","text":"<pre><code>request_insert(row_list, callback=None)\n</code></pre> <p>Add rows to end of table</p> <p>User endpoint for interacting with table and invoking method For input, row list is list of rows. Also note that tables have nine columns by default (x, y, z, r, g, b, sx, sy, sz). x, y, z -&gt; coordinates r, g, b -&gt; color values [0, 1] sx, sy, sz -&gt; scaling factors, default size is 1 meter</p> <p>Row_list: [[1, 2, 3, 4, 5, 6, 7, 8, 9]]</p> <p>Parameters:</p> Name Type Description Default <code>row_list</code> <code>list</code> <p>add rows using list of rows</p> required <code>callback</code> <code>function</code> <p>callback function</p> <code>None</code> Source code in <code>penne/delegates.py</code> <pre><code>def request_insert(self, row_list: List[List[int]], callback=None):\n\"\"\"Add rows to end of table\n\n    User endpoint for interacting with table and invoking method\n    For input, row list is list of rows. Also note that tables have\n    nine columns by default (x, y, z, r, g, b, sx, sy, sz).\n    x, y, z -&gt; coordinates\n    r, g, b -&gt; color values [0, 1]\n    sx, sy, sz -&gt; scaling factors, default size is 1 meter\n\n    Row_list: [[1, 2, 3, 4, 5, 6, 7, 8, 9]]\n\n    Args:\n        row_list (list, optional): add rows using list of rows\n        callback (function, optional): callback function\n    \"\"\"\n\n    self.tbl_insert(row_list, callback=callback)\n</code></pre>"},{"location":"api_reference/delegates/#penne.Table.request_remove","title":"request_remove","text":"<pre><code>request_remove(keys, callback=None)\n</code></pre> <p>Remove rows from table by their keys</p> <p>User endpoint for interacting with table and invoking method</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list</code> <p>list of keys for rows to be removed</p> required <code>callback</code> <code>function</code> <p>callback function called when complete</p> <code>None</code> Source code in <code>penne/delegates.py</code> <pre><code>def request_remove(self, keys: List[int], callback=None):\n\"\"\"Remove rows from table by their keys\n\n    User endpoint for interacting with table and invoking method\n\n    Args:\n        keys (list):\n            list of keys for rows to be removed\n        callback (function, optional):\n            callback function called when complete\n    \"\"\"\n\n    self.tbl_remove(keys, callback=callback)\n</code></pre>"},{"location":"api_reference/delegates/#penne.Table.request_update","title":"request_update","text":"<pre><code>request_update(keys, rows, callback=None)\n</code></pre> <p>Update the table using a DataFrame</p> <p>User endpoint for interacting with table and invoking method</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[int]</code> <p>list of keys to update</p> required <code>rows</code> <code>list[list[int]]</code> <p>list of new rows to update with</p> required <code>callback</code> <code>function</code> <p>callback function called when complete</p> <code>None</code> Source code in <code>penne/delegates.py</code> <pre><code>def request_update(self, keys: List[int], rows: List[List[int]], callback=None):\n\"\"\"Update the table using a DataFrame\n\n    User endpoint for interacting with table and invoking method\n\n    Args:\n        keys (list[int]):\n            list of keys to update\n        rows (list[list[int]]):\n            list of new rows to update with\n        callback (function, optional):\n            callback function called when complete\n    \"\"\"\n\n    self.tbl_update(keys, rows, callback=callback)\n</code></pre>"},{"location":"api_reference/delegates/#penne.Table.request_update_selection","title":"request_update_selection","text":"<pre><code>request_update_selection(name, keys, callback=None)\n</code></pre> <p>Update a selection object in the table</p> <p>User endpoint for interacting with table and invoking method</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the selection object to be updated</p> required <code>keys</code> <code>list</code> <p>list of keys to be in new selection</p> required <code>callback</code> <code>function</code> <p>callback function called when complete</p> <code>None</code> Source code in <code>penne/delegates.py</code> <pre><code>def request_update_selection(self, name: str, keys: List[int], callback=None):\n\"\"\"Update a selection object in the table\n\n    User endpoint for interacting with table and invoking method\n\n    Args:\n        name (str):\n            name of the selection object to be updated\n        keys (list):\n            list of keys to be in new selection\n        callback (function, optional):\n            callback function called when complete\n    \"\"\"\n    selection = Selection(name=name, rows=keys)\n    self.tbl_update_selection(selection.model_dump(), callback=callback)\n</code></pre>"},{"location":"api_reference/delegates/#penne.Table.show_methods","title":"show_methods","text":"<pre><code>show_methods()\n</code></pre> <p>Show methods available on the table</p> Source code in <code>penne/delegates.py</code> <pre><code>def show_methods(self):\n\"\"\"Show methods available on the table\"\"\"\n\n    if self.methods_list is None:\n        message = \"No methods available\"\n    else:\n        message = f\"-- Methods on {self.name} --\\n--------------------------------------\\n\"\n        for method_id in self.methods_list:\n            method = self.client.get_delegate(method_id)\n            message += f\"&gt;&gt; {method}\"\n\n    print(message)\n    return message\n</code></pre>"},{"location":"api_reference/delegates/#penne.Table.subscribe","title":"subscribe","text":"<pre><code>subscribe(callback=None)\n</code></pre> <p>Subscribe to this delegate's table</p> <p>Calls on_table_init as callback</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>function to be called after table is subscribed to and initialized</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Could not subscribe to table</p> Source code in <code>penne/delegates.py</code> <pre><code>def subscribe(self, callback: Callable = None):\n\"\"\"Subscribe to this delegate's table\n\n    Calls on_table_init as callback\n\n    Args:\n          callback (Callable): function to be called after table is subscribed to and initialized\n\n    Raises:\n        Exception: Could not subscribe to table\n    \"\"\"\n\n    try:\n        # Allow for callback after table init\n        self.tbl_subscribe(callback=lambda data: self._on_table_init(data, callback))\n    except Exception as e:\n        raise Exception(f\"Could not subscribe to table {self.id}...{e}\")\n</code></pre>"},{"location":"api_reference/delegates/#penne.Document","title":"penne.Document","text":"<p>             Bases: <code>Delegate</code></p> <p>Delegate for document</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name will be \"Document\"</p> <code>methods_list</code> <code>list[MethodID]</code> <p>list of methods available on the document</p> <code>signals_list</code> <code>list[SignalID]</code> <p>list of signals available on the document</p>"},{"location":"api_reference/delegates/#penne.Document.on_update","title":"on_update","text":"<pre><code>on_update(message)\n</code></pre> <p>Handler when update message is received</p> <p>Should update methods_list and signals_list</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>update message with the new document's info</p> required Source code in <code>penne/delegates.py</code> <pre><code>def on_update(self, message: dict):\n\"\"\"Handler when update message is received\n\n    Should update methods_list and signals_list\n\n    Args:\n        message (Message): update message with the new document's info\n    \"\"\"\n    if \"methods_list\" in message:\n        self.methods_list = [MethodID(*element) for element in message[\"methods_list\"]]\n        inject_methods(self, self.methods_list)\n    if \"signals_list\" in message:\n        self.signals_list = [SignalID(*element) for element in message[\"signals_list\"]]\n</code></pre>"},{"location":"api_reference/delegates/#penne.Document.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the document</p> <p>Called when document reset message is received. Will reset state, and clear methods and signals on document</p> Source code in <code>penne/delegates.py</code> <pre><code>def reset(self):\n\"\"\"Reset the document\n\n    Called when document reset message is received. Will reset state, and clear methods and signals on document\n    \"\"\"\n    self.client.state = {\"document\": self}\n    self.methods_list = []\n    self.signals_list = []\n</code></pre>"},{"location":"api_reference/delegates/#penne.Document.show_methods","title":"show_methods","text":"<pre><code>show_methods()\n</code></pre> <p>Show methods available on the document</p> Source code in <code>penne/delegates.py</code> <pre><code>def show_methods(self):\n\"\"\"Show methods available on the document\"\"\"\n\n    if not self.methods_list:\n        message = \"No methods available\"\n    else:\n        message = f\"-- Methods on Document --\\n--------------------------------------\\n\"\n        for method_id in self.methods_list:\n            method = self.client.get_delegate(method_id)\n            message += f\"&gt;&gt; {method}\"\n\n    print(message)\n    return message\n</code></pre>"},{"location":"api_reference/delegates/#penne.Document.update_client_view","title":"update_client_view","text":"<pre><code>update_client_view(direction, angle)\n</code></pre> <p>Notify the server of an area of interest for the client</p> Source code in <code>penne/delegates.py</code> <pre><code>def update_client_view(self, direction: Vec3, angle: float):\n\"\"\"Notify the server of an area of interest for the client\"\"\"\n\n    self.client_view(direction, angle)\n</code></pre>"},{"location":"api_reference/delegates/#penne.Reply","title":"penne.Reply","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Reply message sent from server in response to method invocation</p> <p>Will either contain resulting data, or an exception</p> <p>Attributes:</p> Name Type Description <code>invoke_id</code> <code>str</code> <p>id of the invoke message that this is a reply to</p> <code>result</code> <code>Any</code> <p>result of the method invocation</p> <code>method_exception</code> <code>MethodException</code> <p>exception raised when invoking method</p>"},{"location":"api_reference/support_objects/","title":"Supporting Objects","text":"<p>These are objects that are used by other components in the library.</p>"},{"location":"api_reference/support_objects/#ids","title":"ID's","text":""},{"location":"api_reference/support_objects/#penne.ID","title":"penne.ID","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Base class for all ID's</p> <p>Each ID is composed of a slot and a generation, resulting in a tuple like id ex. (0, 0). Both are positive integers that are filled in increasing order. Slots are taken first, but once the slot is freed, it can be used with a new generation. For example, a method is created -&gt; (0, 0), then another is created -&gt; (1, 0), then method (0, 0) is deleted. Now, the next method created will be (0, 1).</p> <p>Attributes:</p> Name Type Description <code>slot</code> <code>int</code> <p>Slot of the ID</p> <code>gen</code> <code>int</code> <p>Generation of the ID</p>"},{"location":"api_reference/support_objects/#penne.MethodID","title":"penne.MethodID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to methods</p>"},{"location":"api_reference/support_objects/#penne.SignalID","title":"penne.SignalID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to signals</p>"},{"location":"api_reference/support_objects/#penne.EntityID","title":"penne.EntityID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to entities</p>"},{"location":"api_reference/support_objects/#penne.PlotID","title":"penne.PlotID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to plots</p>"},{"location":"api_reference/support_objects/#penne.BufferID","title":"penne.BufferID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to buffers</p>"},{"location":"api_reference/support_objects/#penne.BufferViewID","title":"penne.BufferViewID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to buffer views</p>"},{"location":"api_reference/support_objects/#penne.MaterialID","title":"penne.MaterialID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to materials</p>"},{"location":"api_reference/support_objects/#penne.ImageID","title":"penne.ImageID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to images</p>"},{"location":"api_reference/support_objects/#penne.TextureID","title":"penne.TextureID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to textures</p>"},{"location":"api_reference/support_objects/#penne.SamplerID","title":"penne.SamplerID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to samplers</p>"},{"location":"api_reference/support_objects/#penne.LightID","title":"penne.LightID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to lights</p>"},{"location":"api_reference/support_objects/#penne.GeometryID","title":"penne.GeometryID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to geometries</p>"},{"location":"api_reference/support_objects/#penne.TableID","title":"penne.TableID","text":"<p>             Bases: <code>ID</code></p> <p>ID specific to tables</p>"},{"location":"api_reference/support_objects/#enums-for-specific-string-options","title":"Enums for Specific String Options","text":""},{"location":"api_reference/support_objects/#penne.AttributeSemantic","title":"penne.AttributeSemantic","text":"<p>             Bases: <code>Enum</code></p> <p>String indicating type of attribute, used in Attribute inside of geometry patch</p> <p>Takes value of either POSITION, NORMAL, TANGENT, TEXTURE, or COLOR</p>"},{"location":"api_reference/support_objects/#penne.Format","title":"penne.Format","text":"<p>             Bases: <code>Enum</code></p> <p>String indicating format of byte data for an attribute</p> <p>Used in Attribute inside of geometry patch. Takes value of either U8, U16, U32, U8VEC4, U16VEC2, VEC2, VEC3, VEC4, MAT3, or MAT4</p>"},{"location":"api_reference/support_objects/#penne.IndexFormat","title":"penne.IndexFormat","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>String indicating format of byte data for an index</p> <p>Used in Index inside of geometry patch. Takes value of either U8, U16, or U32</p>"},{"location":"api_reference/support_objects/#penne.PrimitiveType","title":"penne.PrimitiveType","text":"<p>             Bases: <code>Enum</code></p> <p>String indicating type of primitive used in a geometry patch</p> <p>Takes value of either POINTS, LINES, LINE_LOOP, LINE_STRIP, TRIANGLES, or TRIANGLE_STRIP</p>"},{"location":"api_reference/support_objects/#penne.ColumnType","title":"penne.ColumnType","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>String indicating type of data stored in a column in a table</p> <p>Used in TableColumnInfo inside TableInitData. Takes value of either TEXT, REAL, or INTEGER</p>"},{"location":"api_reference/support_objects/#penne.BufferType","title":"penne.BufferType","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>String indicating type of data stored in a buffer</p> <p>Used in BufferView. Takes value of either UNK, GEOMETRY, or IMAGE</p>"},{"location":"api_reference/support_objects/#penne.SamplerMode","title":"penne.SamplerMode","text":"<p>             Bases: <code>Enum</code></p> <p>String options for sampler mode</p> <p>Used in Sampler. Takes value of either CLAMP_TO_EDGE, MIRRORED_REPEAT, or REPEAT</p>"},{"location":"api_reference/support_objects/#penne.MagFilterTypes","title":"penne.MagFilterTypes","text":"<p>             Bases: <code>Enum</code></p> <p>Options for magnification filter type</p> <p>Used in Sampler. Takes value of either NEAREST or LINEAR</p>"},{"location":"api_reference/support_objects/#penne.MinFilterTypes","title":"penne.MinFilterTypes","text":"<p>             Bases: <code>Enum</code></p> <p>Options for minification filter type</p> <p>Used in Sampler. Takes value of either NEAREST, LINEAR, or LINEAR_MIPMAP_LINEAR</p>"},{"location":"api_reference/support_objects/#supporting-objects_1","title":"Supporting Objects","text":""},{"location":"api_reference/support_objects/#penne.SelectionRange","title":"penne.SelectionRange","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Range of rows to select in a table</p> <p>Attributes:</p> Name Type Description <code>key_from_inclusive</code> <code>int</code> <p>First row to select</p> <code>key_to_exclusive</code> <code>int</code> <p>Where to end selection, exclusive</p>"},{"location":"api_reference/support_objects/#penne.Selection","title":"penne.Selection","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Selection of rows in a table</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of selection</p> <code>rows</code> <code>List[int]</code> <p>List of rows to select</p> <code>row_ranges</code> <code>List[SelectionRange]</code> <p>List of ranges of rows to select</p>"},{"location":"api_reference/support_objects/#penne.MethodArg","title":"penne.MethodArg","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Argument for a method</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of argument</p> <code>doc</code> <code>str</code> <p>Documentation for argument</p> <code>editor_hint</code> <code>str</code> <p>Hint for editor, refer to message spec for hint options</p>"},{"location":"api_reference/support_objects/#penne.BoundingBox","title":"penne.BoundingBox","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Axis-aligned bounding box</p> <p>Attributes:</p> Name Type Description <code>min</code> <code>Vec3</code> <p>Minimum point of bounding box</p> <code>max</code> <code>Vec3</code> <p>Maximum point of bounding box</p>"},{"location":"api_reference/support_objects/#penne.TextRepresentation","title":"penne.TextRepresentation","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Text representation for an entity</p> <p>Attributes:</p> Name Type Description <code>txt</code> <code>str</code> <p>Text to display</p> <code>font</code> <code>str</code> <p>Font to use</p> <code>height</code> <code>Optional[float]</code> <p>Height of text</p> <code>width</code> <code>Optional[float]</code> <p>Width of text</p>"},{"location":"api_reference/support_objects/#penne.WebRepresentation","title":"penne.WebRepresentation","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Web page with a given URL rendered as a plane</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>str</code> <p>URL for entity</p> <code>height</code> <code>Optional[float]</code> <p>Height of plane</p> <code>width</code> <code>Optional[float]</code> <p>Width of plane</p>"},{"location":"api_reference/support_objects/#penne.InstanceSource","title":"penne.InstanceSource","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Source of instances for a geometry patch</p> <p>Attributes:</p> Name Type Description <code>view</code> <code>BufferViewID</code> <p>View of mat4</p> <code>stride</code> <code>int</code> <p>Stride for buffer, defaults to tightly packed</p> <code>bb</code> <code>BoundingBox</code> <p>Bounding box of instances</p>"},{"location":"api_reference/support_objects/#penne.RenderRepresentation","title":"penne.RenderRepresentation","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Render representation for an entity</p> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>GeometryID</code> <p>Mesh to render</p> <code>instances</code> <code>Optional[InstanceSource]</code> <p>Source of instances for mesh</p>"},{"location":"api_reference/support_objects/#penne.TextureRef","title":"penne.TextureRef","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Reference to a texture</p> <p>Attributes:</p> Name Type Description <code>texture</code> <code>TextureID</code> <p>Texture to reference</p> <code>transform</code> <code>Optional[Mat3]</code> <p>Transform to apply to texture</p> <code>texture_coord_slot</code> <code>Optional[int]</code> <p>Texture coordinate slot to use</p>"},{"location":"api_reference/support_objects/#penne.PBRInfo","title":"penne.PBRInfo","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Physically based rendering information for a material</p> <p>Attributes:</p> Name Type Description <code>base_color</code> <code>Optional[RGBA]</code> <p>Base color of material</p> <code>base_color_texture</code> <code>Optional[TextureRef]</code> <p>Texture to use for base color</p> <code>metallic</code> <code>Optional[float]</code> <p>Metallic value of material</p> <code>roughness</code> <code>Optional[float]</code> <p>Roughness value of material</p> <code>metal_rough_texture</code> <code>Optional[TextureRef]</code> <p>Texture to use for metallic and roughness</p>"},{"location":"api_reference/support_objects/#penne.PointLight","title":"penne.PointLight","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Point light information for a light delegate</p> <p>Attributes:</p> Name Type Description <code>range</code> <code>float</code> <p>Range of light, -1 defaults to infinite</p>"},{"location":"api_reference/support_objects/#penne.SpotLight","title":"penne.SpotLight","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Spotlight information for a light delegate</p> <p>Attributes:</p> Name Type Description <code>range</code> <code>float</code> <p>Range of light, -1 defaults to infinite</p> <code>inner_cone_angle_rad</code> <code>float</code> <p>Inner cone angle of light</p> <code>outer_cone_angle_rad</code> <code>float</code> <p>Outer cone angle of light</p>"},{"location":"api_reference/support_objects/#penne.DirectionalLight","title":"penne.DirectionalLight","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Directional light information for a light delegate</p> <p>Attributes:</p> Name Type Description <code>range</code> <code>float</code> <p>Range of light, -1 defaults to infinite</p>"},{"location":"api_reference/support_objects/#penne.Attribute","title":"penne.Attribute","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Attribute for a geometry patch</p> <p>Each attribute is a view into a buffer that corresponds to a specific element of the mesh (e.g. position, normal, etc.). Attributes allow information for the vertices to be extracted from buffers</p> <p>Attributes:</p> Name Type Description <code>view</code> <code>BufferViewID</code> <p>View of the buffer storing the data</p> <code>semantic</code> <code>AttributeSemantic</code> <p>String describing the type of attribute</p> <code>channel</code> <code>Optional[int]</code> <p>Channel of attribute, if applicable</p> <code>offset</code> <code>Optional[int]</code> <p>Offset into buffer</p> <code>stride</code> <code>Optional[int]</code> <p>Distance, in bytes, between data for two vertices in the buffer</p> <code>format</code> <code>Format</code> <p>How many bytes per element, how to decode the bytes</p> <code>minimum_value</code> <code>Optional[List[float]]</code> <p>Minimum value for attribute data</p> <code>maximum_value</code> <code>Optional[List[float]]</code> <p>Maximum value for attribute data</p> <code>normalized</code> <code>Optional[bool]</code> <p>Whether to normalize the attribute data</p>"},{"location":"api_reference/support_objects/#penne.Index","title":"penne.Index","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Index for a geometry patch</p> <p>The index is a view into a buffer that corresponds to the indices of the mesh. The index allows the mesh to connect vertices and render triangles, lines, or points.</p> <p>Attributes:</p> Name Type Description <code>view</code> <code>BufferViewID</code> <p>View of the buffer storing the data</p> <code>count</code> <code>int</code> <p>Number of indices</p> <code>offset</code> <code>Optional[int]</code> <p>Offset into buffer</p> <code>stride</code> <code>Optional[int]</code> <p>Distance, in bytes, between data for two elements in the buffer</p> <code>format</code> <code>IndexFormat</code> <p>How many bytes per element, how to decode the bytes</p>"},{"location":"api_reference/support_objects/#penne.GeometryPatch","title":"penne.GeometryPatch","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Geometry patch for a mesh</p> <p>Principle object used in geometry delegates. A geometry patch combines vertex data from attributes and index data from indices.</p> <p>Attributes:</p> Name Type Description <code>attributes</code> <code>List[Attribute]</code> <p>List of attributes storing vertex data for the mesh</p> <code>vertex_count</code> <code>int</code> <p>Number of vertices in the mesh</p> <code>indices</code> <code>Optional[Index]</code> <p>Indices for the mesh</p> <code>type</code> <code>PrimitiveType</code> <p>Type of primitive to render</p> <code>material</code> <code>MaterialID</code> <p>Material to use for rendering</p>"},{"location":"api_reference/support_objects/#penne.InvokeIDType","title":"penne.InvokeIDType","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Context for invoking a signal</p> <p>Attributes:</p> Name Type Description <code>entity</code> <code>Optional[EntityID]</code> <p>Entity to invoke signal on</p> <code>table</code> <code>Optional[TableID]</code> <p>Table to invoke signal on</p> <code>plot</code> <code>Optional[PlotID]</code> <p>Plot to invoke signal on</p>"},{"location":"api_reference/support_objects/#penne.TableColumnInfo","title":"penne.TableColumnInfo","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Information about a column in a table</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of column</p> <code>type</code> <code>ColumnType</code> <p>Type data in the column</p>"},{"location":"api_reference/support_objects/#penne.TableInitData","title":"penne.TableInitData","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Init data to create a table</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>List[TableColumnInfo]</code> <p>List of column information</p> <code>keys</code> <code>List[int]</code> <p>List of column indices that are keys</p> <code>data</code> <code>List[List[Any]]</code> <p>List of rows of data</p> <code>selections</code> <code>Optional[List[Selection]]</code> <p>List of selections to apply to table</p>"},{"location":"api_reference/support_objects/#penne.MethodException","title":"penne.MethodException","text":"<p>             Bases: <code>NoodleObject</code></p> <p>Exception raised when invoking a method</p> <p>Will be sent as part of a reply message</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>int</code> <p>error code</p> <code>message</code> <code>str</code> <p>error message</p> <code>data</code> <code>Any</code> <p>data associated with the error</p>"}]}